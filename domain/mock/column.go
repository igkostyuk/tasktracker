// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"context"
	"github.com/google/uuid"
	"github.com/igkostyuk/tasktracker/domain"
	"sync"
)

// Ensure, that ColumnUsecaseMock does implement domain.ColumnUsecase.
// If this is not the case, regenerate this file with moq.
var _ domain.ColumnUsecase = &ColumnUsecaseMock{}

// ColumnUsecaseMock is a mock implementation of domain.ColumnUsecase.
//
//     func TestSomethingThatUsesColumnUsecase(t *testing.T) {
//
//         // make and configure a mocked domain.ColumnUsecase
//         mockedColumnUsecase := &ColumnUsecaseMock{
//             DeleteFunc: func(ctx context.Context, id uuid.UUID) error {
// 	               panic("mock out the Delete method")
//             },
//             FetchFunc: func(ctx context.Context) ([]domain.Column, error) {
// 	               panic("mock out the Fetch method")
//             },
//             FetchByProjectIDFunc: func(ctx context.Context, id uuid.UUID) ([]domain.Column, error) {
// 	               panic("mock out the FetchByProjectID method")
//             },
//             FetchTasksFunc: func(ctx context.Context, id uuid.UUID) ([]domain.Task, error) {
// 	               panic("mock out the FetchTasks method")
//             },
//             GetByIDFunc: func(ctx context.Context, id uuid.UUID) (domain.Column, error) {
// 	               panic("mock out the GetByID method")
//             },
//             StoreFunc: func(in1 context.Context, in2 *domain.Column) error {
// 	               panic("mock out the Store method")
//             },
//             UpdateFunc: func(ctx context.Context, cl *domain.Column) error {
// 	               panic("mock out the Update method")
//             },
//         }
//
//         // use mockedColumnUsecase in code that requires domain.ColumnUsecase
//         // and then make assertions.
//
//     }
type ColumnUsecaseMock struct {
	// DeleteFunc mocks the Delete method.
	DeleteFunc func(ctx context.Context, id uuid.UUID) error

	// FetchFunc mocks the Fetch method.
	FetchFunc func(ctx context.Context) ([]domain.Column, error)

	// FetchByProjectIDFunc mocks the FetchByProjectID method.
	FetchByProjectIDFunc func(ctx context.Context, id uuid.UUID) ([]domain.Column, error)

	// FetchTasksFunc mocks the FetchTasks method.
	FetchTasksFunc func(ctx context.Context, id uuid.UUID) ([]domain.Task, error)

	// GetByIDFunc mocks the GetByID method.
	GetByIDFunc func(ctx context.Context, id uuid.UUID) (domain.Column, error)

	// StoreFunc mocks the Store method.
	StoreFunc func(in1 context.Context, in2 *domain.Column) error

	// UpdateFunc mocks the Update method.
	UpdateFunc func(ctx context.Context, cl *domain.Column) error

	// calls tracks calls to the methods.
	calls struct {
		// Delete holds details about calls to the Delete method.
		Delete []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID uuid.UUID
		}
		// Fetch holds details about calls to the Fetch method.
		Fetch []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// FetchByProjectID holds details about calls to the FetchByProjectID method.
		FetchByProjectID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID uuid.UUID
		}
		// FetchTasks holds details about calls to the FetchTasks method.
		FetchTasks []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID uuid.UUID
		}
		// GetByID holds details about calls to the GetByID method.
		GetByID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID uuid.UUID
		}
		// Store holds details about calls to the Store method.
		Store []struct {
			// In1 is the in1 argument value.
			In1 context.Context
			// In2 is the in2 argument value.
			In2 *domain.Column
		}
		// Update holds details about calls to the Update method.
		Update []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Cl is the cl argument value.
			Cl *domain.Column
		}
	}
	lockDelete           sync.RWMutex
	lockFetch            sync.RWMutex
	lockFetchByProjectID sync.RWMutex
	lockFetchTasks       sync.RWMutex
	lockGetByID          sync.RWMutex
	lockStore            sync.RWMutex
	lockUpdate           sync.RWMutex
}

// Delete calls DeleteFunc.
func (mock *ColumnUsecaseMock) Delete(ctx context.Context, id uuid.UUID) error {
	if mock.DeleteFunc == nil {
		panic("ColumnUsecaseMock.DeleteFunc: method is nil but ColumnUsecase.Delete was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  uuid.UUID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockDelete.Lock()
	mock.calls.Delete = append(mock.calls.Delete, callInfo)
	mock.lockDelete.Unlock()
	return mock.DeleteFunc(ctx, id)
}

// DeleteCalls gets all the calls that were made to Delete.
// Check the length with:
//     len(mockedColumnUsecase.DeleteCalls())
func (mock *ColumnUsecaseMock) DeleteCalls() []struct {
	Ctx context.Context
	ID  uuid.UUID
} {
	var calls []struct {
		Ctx context.Context
		ID  uuid.UUID
	}
	mock.lockDelete.RLock()
	calls = mock.calls.Delete
	mock.lockDelete.RUnlock()
	return calls
}

// Fetch calls FetchFunc.
func (mock *ColumnUsecaseMock) Fetch(ctx context.Context) ([]domain.Column, error) {
	if mock.FetchFunc == nil {
		panic("ColumnUsecaseMock.FetchFunc: method is nil but ColumnUsecase.Fetch was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockFetch.Lock()
	mock.calls.Fetch = append(mock.calls.Fetch, callInfo)
	mock.lockFetch.Unlock()
	return mock.FetchFunc(ctx)
}

// FetchCalls gets all the calls that were made to Fetch.
// Check the length with:
//     len(mockedColumnUsecase.FetchCalls())
func (mock *ColumnUsecaseMock) FetchCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockFetch.RLock()
	calls = mock.calls.Fetch
	mock.lockFetch.RUnlock()
	return calls
}

// FetchByProjectID calls FetchByProjectIDFunc.
func (mock *ColumnUsecaseMock) FetchByProjectID(ctx context.Context, id uuid.UUID) ([]domain.Column, error) {
	if mock.FetchByProjectIDFunc == nil {
		panic("ColumnUsecaseMock.FetchByProjectIDFunc: method is nil but ColumnUsecase.FetchByProjectID was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  uuid.UUID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockFetchByProjectID.Lock()
	mock.calls.FetchByProjectID = append(mock.calls.FetchByProjectID, callInfo)
	mock.lockFetchByProjectID.Unlock()
	return mock.FetchByProjectIDFunc(ctx, id)
}

// FetchByProjectIDCalls gets all the calls that were made to FetchByProjectID.
// Check the length with:
//     len(mockedColumnUsecase.FetchByProjectIDCalls())
func (mock *ColumnUsecaseMock) FetchByProjectIDCalls() []struct {
	Ctx context.Context
	ID  uuid.UUID
} {
	var calls []struct {
		Ctx context.Context
		ID  uuid.UUID
	}
	mock.lockFetchByProjectID.RLock()
	calls = mock.calls.FetchByProjectID
	mock.lockFetchByProjectID.RUnlock()
	return calls
}

// FetchTasks calls FetchTasksFunc.
func (mock *ColumnUsecaseMock) FetchTasks(ctx context.Context, id uuid.UUID) ([]domain.Task, error) {
	if mock.FetchTasksFunc == nil {
		panic("ColumnUsecaseMock.FetchTasksFunc: method is nil but ColumnUsecase.FetchTasks was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  uuid.UUID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockFetchTasks.Lock()
	mock.calls.FetchTasks = append(mock.calls.FetchTasks, callInfo)
	mock.lockFetchTasks.Unlock()
	return mock.FetchTasksFunc(ctx, id)
}

// FetchTasksCalls gets all the calls that were made to FetchTasks.
// Check the length with:
//     len(mockedColumnUsecase.FetchTasksCalls())
func (mock *ColumnUsecaseMock) FetchTasksCalls() []struct {
	Ctx context.Context
	ID  uuid.UUID
} {
	var calls []struct {
		Ctx context.Context
		ID  uuid.UUID
	}
	mock.lockFetchTasks.RLock()
	calls = mock.calls.FetchTasks
	mock.lockFetchTasks.RUnlock()
	return calls
}

// GetByID calls GetByIDFunc.
func (mock *ColumnUsecaseMock) GetByID(ctx context.Context, id uuid.UUID) (domain.Column, error) {
	if mock.GetByIDFunc == nil {
		panic("ColumnUsecaseMock.GetByIDFunc: method is nil but ColumnUsecase.GetByID was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  uuid.UUID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockGetByID.Lock()
	mock.calls.GetByID = append(mock.calls.GetByID, callInfo)
	mock.lockGetByID.Unlock()
	return mock.GetByIDFunc(ctx, id)
}

// GetByIDCalls gets all the calls that were made to GetByID.
// Check the length with:
//     len(mockedColumnUsecase.GetByIDCalls())
func (mock *ColumnUsecaseMock) GetByIDCalls() []struct {
	Ctx context.Context
	ID  uuid.UUID
} {
	var calls []struct {
		Ctx context.Context
		ID  uuid.UUID
	}
	mock.lockGetByID.RLock()
	calls = mock.calls.GetByID
	mock.lockGetByID.RUnlock()
	return calls
}

// Store calls StoreFunc.
func (mock *ColumnUsecaseMock) Store(in1 context.Context, in2 *domain.Column) error {
	if mock.StoreFunc == nil {
		panic("ColumnUsecaseMock.StoreFunc: method is nil but ColumnUsecase.Store was just called")
	}
	callInfo := struct {
		In1 context.Context
		In2 *domain.Column
	}{
		In1: in1,
		In2: in2,
	}
	mock.lockStore.Lock()
	mock.calls.Store = append(mock.calls.Store, callInfo)
	mock.lockStore.Unlock()
	return mock.StoreFunc(in1, in2)
}

// StoreCalls gets all the calls that were made to Store.
// Check the length with:
//     len(mockedColumnUsecase.StoreCalls())
func (mock *ColumnUsecaseMock) StoreCalls() []struct {
	In1 context.Context
	In2 *domain.Column
} {
	var calls []struct {
		In1 context.Context
		In2 *domain.Column
	}
	mock.lockStore.RLock()
	calls = mock.calls.Store
	mock.lockStore.RUnlock()
	return calls
}

// Update calls UpdateFunc.
func (mock *ColumnUsecaseMock) Update(ctx context.Context, cl *domain.Column) error {
	if mock.UpdateFunc == nil {
		panic("ColumnUsecaseMock.UpdateFunc: method is nil but ColumnUsecase.Update was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Cl  *domain.Column
	}{
		Ctx: ctx,
		Cl:  cl,
	}
	mock.lockUpdate.Lock()
	mock.calls.Update = append(mock.calls.Update, callInfo)
	mock.lockUpdate.Unlock()
	return mock.UpdateFunc(ctx, cl)
}

// UpdateCalls gets all the calls that were made to Update.
// Check the length with:
//     len(mockedColumnUsecase.UpdateCalls())
func (mock *ColumnUsecaseMock) UpdateCalls() []struct {
	Ctx context.Context
	Cl  *domain.Column
} {
	var calls []struct {
		Ctx context.Context
		Cl  *domain.Column
	}
	mock.lockUpdate.RLock()
	calls = mock.calls.Update
	mock.lockUpdate.RUnlock()
	return calls
}

// Ensure, that ColumnRepositoryMock does implement domain.ColumnRepository.
// If this is not the case, regenerate this file with moq.
var _ domain.ColumnRepository = &ColumnRepositoryMock{}

// ColumnRepositoryMock is a mock implementation of domain.ColumnRepository.
//
//     func TestSomethingThatUsesColumnRepository(t *testing.T) {
//
//         // make and configure a mocked domain.ColumnRepository
//         mockedColumnRepository := &ColumnRepositoryMock{
//             DeleteFunc: func(ctx context.Context, id uuid.UUID) error {
// 	               panic("mock out the Delete method")
//             },
//             FetchFunc: func(ctx context.Context) ([]domain.Column, error) {
// 	               panic("mock out the Fetch method")
//             },
//             FetchByProjectIDFunc: func(ctx context.Context, id uuid.UUID) ([]domain.Column, error) {
// 	               panic("mock out the FetchByProjectID method")
//             },
//             GetByIDFunc: func(ctx context.Context, id uuid.UUID) (domain.Column, error) {
// 	               panic("mock out the GetByID method")
//             },
//             StoreFunc: func(ctx context.Context, c *domain.Column) error {
// 	               panic("mock out the Store method")
//             },
//             UpdateFunc: func(ctx context.Context, cl *domain.Column) error {
// 	               panic("mock out the Update method")
//             },
//         }
//
//         // use mockedColumnRepository in code that requires domain.ColumnRepository
//         // and then make assertions.
//
//     }
type ColumnRepositoryMock struct {
	// DeleteFunc mocks the Delete method.
	DeleteFunc func(ctx context.Context, id uuid.UUID) error

	// FetchFunc mocks the Fetch method.
	FetchFunc func(ctx context.Context) ([]domain.Column, error)

	// FetchByProjectIDFunc mocks the FetchByProjectID method.
	FetchByProjectIDFunc func(ctx context.Context, id uuid.UUID) ([]domain.Column, error)

	// GetByIDFunc mocks the GetByID method.
	GetByIDFunc func(ctx context.Context, id uuid.UUID) (domain.Column, error)

	// StoreFunc mocks the Store method.
	StoreFunc func(ctx context.Context, c *domain.Column) error

	// UpdateFunc mocks the Update method.
	UpdateFunc func(ctx context.Context, cl *domain.Column) error

	// calls tracks calls to the methods.
	calls struct {
		// Delete holds details about calls to the Delete method.
		Delete []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID uuid.UUID
		}
		// Fetch holds details about calls to the Fetch method.
		Fetch []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// FetchByProjectID holds details about calls to the FetchByProjectID method.
		FetchByProjectID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID uuid.UUID
		}
		// GetByID holds details about calls to the GetByID method.
		GetByID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID uuid.UUID
		}
		// Store holds details about calls to the Store method.
		Store []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// C is the c argument value.
			C *domain.Column
		}
		// Update holds details about calls to the Update method.
		Update []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Cl is the cl argument value.
			Cl *domain.Column
		}
	}
	lockDelete           sync.RWMutex
	lockFetch            sync.RWMutex
	lockFetchByProjectID sync.RWMutex
	lockGetByID          sync.RWMutex
	lockStore            sync.RWMutex
	lockUpdate           sync.RWMutex
}

// Delete calls DeleteFunc.
func (mock *ColumnRepositoryMock) Delete(ctx context.Context, id uuid.UUID) error {
	if mock.DeleteFunc == nil {
		panic("ColumnRepositoryMock.DeleteFunc: method is nil but ColumnRepository.Delete was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  uuid.UUID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockDelete.Lock()
	mock.calls.Delete = append(mock.calls.Delete, callInfo)
	mock.lockDelete.Unlock()
	return mock.DeleteFunc(ctx, id)
}

// DeleteCalls gets all the calls that were made to Delete.
// Check the length with:
//     len(mockedColumnRepository.DeleteCalls())
func (mock *ColumnRepositoryMock) DeleteCalls() []struct {
	Ctx context.Context
	ID  uuid.UUID
} {
	var calls []struct {
		Ctx context.Context
		ID  uuid.UUID
	}
	mock.lockDelete.RLock()
	calls = mock.calls.Delete
	mock.lockDelete.RUnlock()
	return calls
}

// Fetch calls FetchFunc.
func (mock *ColumnRepositoryMock) Fetch(ctx context.Context) ([]domain.Column, error) {
	if mock.FetchFunc == nil {
		panic("ColumnRepositoryMock.FetchFunc: method is nil but ColumnRepository.Fetch was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockFetch.Lock()
	mock.calls.Fetch = append(mock.calls.Fetch, callInfo)
	mock.lockFetch.Unlock()
	return mock.FetchFunc(ctx)
}

// FetchCalls gets all the calls that were made to Fetch.
// Check the length with:
//     len(mockedColumnRepository.FetchCalls())
func (mock *ColumnRepositoryMock) FetchCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockFetch.RLock()
	calls = mock.calls.Fetch
	mock.lockFetch.RUnlock()
	return calls
}

// FetchByProjectID calls FetchByProjectIDFunc.
func (mock *ColumnRepositoryMock) FetchByProjectID(ctx context.Context, id uuid.UUID) ([]domain.Column, error) {
	if mock.FetchByProjectIDFunc == nil {
		panic("ColumnRepositoryMock.FetchByProjectIDFunc: method is nil but ColumnRepository.FetchByProjectID was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  uuid.UUID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockFetchByProjectID.Lock()
	mock.calls.FetchByProjectID = append(mock.calls.FetchByProjectID, callInfo)
	mock.lockFetchByProjectID.Unlock()
	return mock.FetchByProjectIDFunc(ctx, id)
}

// FetchByProjectIDCalls gets all the calls that were made to FetchByProjectID.
// Check the length with:
//     len(mockedColumnRepository.FetchByProjectIDCalls())
func (mock *ColumnRepositoryMock) FetchByProjectIDCalls() []struct {
	Ctx context.Context
	ID  uuid.UUID
} {
	var calls []struct {
		Ctx context.Context
		ID  uuid.UUID
	}
	mock.lockFetchByProjectID.RLock()
	calls = mock.calls.FetchByProjectID
	mock.lockFetchByProjectID.RUnlock()
	return calls
}

// GetByID calls GetByIDFunc.
func (mock *ColumnRepositoryMock) GetByID(ctx context.Context, id uuid.UUID) (domain.Column, error) {
	if mock.GetByIDFunc == nil {
		panic("ColumnRepositoryMock.GetByIDFunc: method is nil but ColumnRepository.GetByID was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  uuid.UUID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockGetByID.Lock()
	mock.calls.GetByID = append(mock.calls.GetByID, callInfo)
	mock.lockGetByID.Unlock()
	return mock.GetByIDFunc(ctx, id)
}

// GetByIDCalls gets all the calls that were made to GetByID.
// Check the length with:
//     len(mockedColumnRepository.GetByIDCalls())
func (mock *ColumnRepositoryMock) GetByIDCalls() []struct {
	Ctx context.Context
	ID  uuid.UUID
} {
	var calls []struct {
		Ctx context.Context
		ID  uuid.UUID
	}
	mock.lockGetByID.RLock()
	calls = mock.calls.GetByID
	mock.lockGetByID.RUnlock()
	return calls
}

// Store calls StoreFunc.
func (mock *ColumnRepositoryMock) Store(ctx context.Context, c *domain.Column) error {
	if mock.StoreFunc == nil {
		panic("ColumnRepositoryMock.StoreFunc: method is nil but ColumnRepository.Store was just called")
	}
	callInfo := struct {
		Ctx context.Context
		C   *domain.Column
	}{
		Ctx: ctx,
		C:   c,
	}
	mock.lockStore.Lock()
	mock.calls.Store = append(mock.calls.Store, callInfo)
	mock.lockStore.Unlock()
	return mock.StoreFunc(ctx, c)
}

// StoreCalls gets all the calls that were made to Store.
// Check the length with:
//     len(mockedColumnRepository.StoreCalls())
func (mock *ColumnRepositoryMock) StoreCalls() []struct {
	Ctx context.Context
	C   *domain.Column
} {
	var calls []struct {
		Ctx context.Context
		C   *domain.Column
	}
	mock.lockStore.RLock()
	calls = mock.calls.Store
	mock.lockStore.RUnlock()
	return calls
}

// Update calls UpdateFunc.
func (mock *ColumnRepositoryMock) Update(ctx context.Context, cl *domain.Column) error {
	if mock.UpdateFunc == nil {
		panic("ColumnRepositoryMock.UpdateFunc: method is nil but ColumnRepository.Update was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Cl  *domain.Column
	}{
		Ctx: ctx,
		Cl:  cl,
	}
	mock.lockUpdate.Lock()
	mock.calls.Update = append(mock.calls.Update, callInfo)
	mock.lockUpdate.Unlock()
	return mock.UpdateFunc(ctx, cl)
}

// UpdateCalls gets all the calls that were made to Update.
// Check the length with:
//     len(mockedColumnRepository.UpdateCalls())
func (mock *ColumnRepositoryMock) UpdateCalls() []struct {
	Ctx context.Context
	Cl  *domain.Column
} {
	var calls []struct {
		Ctx context.Context
		Cl  *domain.Column
	}
	mock.lockUpdate.RLock()
	calls = mock.calls.Update
	mock.lockUpdate.RUnlock()
	return calls
}
