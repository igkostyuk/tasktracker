// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"context"
	"github.com/google/uuid"
	"github.com/igkostyuk/tasktracker/domain"
	"sync"
)

// Ensure, that CommentUsecaseMock does implement domain.CommentUsecase.
// If this is not the case, regenerate this file with moq.
var _ domain.CommentUsecase = &CommentUsecaseMock{}

// CommentUsecaseMock is a mock implementation of domain.CommentUsecase.
//
//     func TestSomethingThatUsesCommentUsecase(t *testing.T) {
//
//         // make and configure a mocked domain.CommentUsecase
//         mockedCommentUsecase := &CommentUsecaseMock{
//             DeleteFunc: func(ctx context.Context, id uuid.UUID) error {
// 	               panic("mock out the Delete method")
//             },
//             FetchFunc: func(ctx context.Context) ([]domain.Comment, error) {
// 	               panic("mock out the Fetch method")
//             },
//             FetchByTaskIDFunc: func(ctx context.Context, id uuid.UUID) ([]domain.Comment, error) {
// 	               panic("mock out the FetchByTaskID method")
//             },
//             GetByIDFunc: func(ctx context.Context, id uuid.UUID) (domain.Comment, error) {
// 	               panic("mock out the GetByID method")
//             },
//             UpdateFunc: func(ctx context.Context, tk *domain.Comment) error {
// 	               panic("mock out the Update method")
//             },
//         }
//
//         // use mockedCommentUsecase in code that requires domain.CommentUsecase
//         // and then make assertions.
//
//     }
type CommentUsecaseMock struct {
	// DeleteFunc mocks the Delete method.
	DeleteFunc func(ctx context.Context, id uuid.UUID) error

	// FetchFunc mocks the Fetch method.
	FetchFunc func(ctx context.Context) ([]domain.Comment, error)

	// FetchByTaskIDFunc mocks the FetchByTaskID method.
	FetchByTaskIDFunc func(ctx context.Context, id uuid.UUID) ([]domain.Comment, error)

	// GetByIDFunc mocks the GetByID method.
	GetByIDFunc func(ctx context.Context, id uuid.UUID) (domain.Comment, error)

	// UpdateFunc mocks the Update method.
	UpdateFunc func(ctx context.Context, tk *domain.Comment) error

	// calls tracks calls to the methods.
	calls struct {
		// Delete holds details about calls to the Delete method.
		Delete []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID uuid.UUID
		}
		// Fetch holds details about calls to the Fetch method.
		Fetch []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// FetchByTaskID holds details about calls to the FetchByTaskID method.
		FetchByTaskID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID uuid.UUID
		}
		// GetByID holds details about calls to the GetByID method.
		GetByID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID uuid.UUID
		}
		// Update holds details about calls to the Update method.
		Update []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Tk is the tk argument value.
			Tk *domain.Comment
		}
	}
	lockDelete        sync.RWMutex
	lockFetch         sync.RWMutex
	lockFetchByTaskID sync.RWMutex
	lockGetByID       sync.RWMutex
	lockUpdate        sync.RWMutex
}

// Delete calls DeleteFunc.
func (mock *CommentUsecaseMock) Delete(ctx context.Context, id uuid.UUID) error {
	if mock.DeleteFunc == nil {
		panic("CommentUsecaseMock.DeleteFunc: method is nil but CommentUsecase.Delete was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  uuid.UUID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockDelete.Lock()
	mock.calls.Delete = append(mock.calls.Delete, callInfo)
	mock.lockDelete.Unlock()
	return mock.DeleteFunc(ctx, id)
}

// DeleteCalls gets all the calls that were made to Delete.
// Check the length with:
//     len(mockedCommentUsecase.DeleteCalls())
func (mock *CommentUsecaseMock) DeleteCalls() []struct {
	Ctx context.Context
	ID  uuid.UUID
} {
	var calls []struct {
		Ctx context.Context
		ID  uuid.UUID
	}
	mock.lockDelete.RLock()
	calls = mock.calls.Delete
	mock.lockDelete.RUnlock()
	return calls
}

// Fetch calls FetchFunc.
func (mock *CommentUsecaseMock) Fetch(ctx context.Context) ([]domain.Comment, error) {
	if mock.FetchFunc == nil {
		panic("CommentUsecaseMock.FetchFunc: method is nil but CommentUsecase.Fetch was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockFetch.Lock()
	mock.calls.Fetch = append(mock.calls.Fetch, callInfo)
	mock.lockFetch.Unlock()
	return mock.FetchFunc(ctx)
}

// FetchCalls gets all the calls that were made to Fetch.
// Check the length with:
//     len(mockedCommentUsecase.FetchCalls())
func (mock *CommentUsecaseMock) FetchCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockFetch.RLock()
	calls = mock.calls.Fetch
	mock.lockFetch.RUnlock()
	return calls
}

// FetchByTaskID calls FetchByTaskIDFunc.
func (mock *CommentUsecaseMock) FetchByTaskID(ctx context.Context, id uuid.UUID) ([]domain.Comment, error) {
	if mock.FetchByTaskIDFunc == nil {
		panic("CommentUsecaseMock.FetchByTaskIDFunc: method is nil but CommentUsecase.FetchByTaskID was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  uuid.UUID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockFetchByTaskID.Lock()
	mock.calls.FetchByTaskID = append(mock.calls.FetchByTaskID, callInfo)
	mock.lockFetchByTaskID.Unlock()
	return mock.FetchByTaskIDFunc(ctx, id)
}

// FetchByTaskIDCalls gets all the calls that were made to FetchByTaskID.
// Check the length with:
//     len(mockedCommentUsecase.FetchByTaskIDCalls())
func (mock *CommentUsecaseMock) FetchByTaskIDCalls() []struct {
	Ctx context.Context
	ID  uuid.UUID
} {
	var calls []struct {
		Ctx context.Context
		ID  uuid.UUID
	}
	mock.lockFetchByTaskID.RLock()
	calls = mock.calls.FetchByTaskID
	mock.lockFetchByTaskID.RUnlock()
	return calls
}

// GetByID calls GetByIDFunc.
func (mock *CommentUsecaseMock) GetByID(ctx context.Context, id uuid.UUID) (domain.Comment, error) {
	if mock.GetByIDFunc == nil {
		panic("CommentUsecaseMock.GetByIDFunc: method is nil but CommentUsecase.GetByID was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  uuid.UUID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockGetByID.Lock()
	mock.calls.GetByID = append(mock.calls.GetByID, callInfo)
	mock.lockGetByID.Unlock()
	return mock.GetByIDFunc(ctx, id)
}

// GetByIDCalls gets all the calls that were made to GetByID.
// Check the length with:
//     len(mockedCommentUsecase.GetByIDCalls())
func (mock *CommentUsecaseMock) GetByIDCalls() []struct {
	Ctx context.Context
	ID  uuid.UUID
} {
	var calls []struct {
		Ctx context.Context
		ID  uuid.UUID
	}
	mock.lockGetByID.RLock()
	calls = mock.calls.GetByID
	mock.lockGetByID.RUnlock()
	return calls
}

// Update calls UpdateFunc.
func (mock *CommentUsecaseMock) Update(ctx context.Context, tk *domain.Comment) error {
	if mock.UpdateFunc == nil {
		panic("CommentUsecaseMock.UpdateFunc: method is nil but CommentUsecase.Update was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Tk  *domain.Comment
	}{
		Ctx: ctx,
		Tk:  tk,
	}
	mock.lockUpdate.Lock()
	mock.calls.Update = append(mock.calls.Update, callInfo)
	mock.lockUpdate.Unlock()
	return mock.UpdateFunc(ctx, tk)
}

// UpdateCalls gets all the calls that were made to Update.
// Check the length with:
//     len(mockedCommentUsecase.UpdateCalls())
func (mock *CommentUsecaseMock) UpdateCalls() []struct {
	Ctx context.Context
	Tk  *domain.Comment
} {
	var calls []struct {
		Ctx context.Context
		Tk  *domain.Comment
	}
	mock.lockUpdate.RLock()
	calls = mock.calls.Update
	mock.lockUpdate.RUnlock()
	return calls
}

// Ensure, that CommentRepositoryMock does implement domain.CommentRepository.
// If this is not the case, regenerate this file with moq.
var _ domain.CommentRepository = &CommentRepositoryMock{}

// CommentRepositoryMock is a mock implementation of domain.CommentRepository.
//
//     func TestSomethingThatUsesCommentRepository(t *testing.T) {
//
//         // make and configure a mocked domain.CommentRepository
//         mockedCommentRepository := &CommentRepositoryMock{
//             DeleteFunc: func(ctx context.Context, id uuid.UUID) error {
// 	               panic("mock out the Delete method")
//             },
//             FetchFunc: func(ctx context.Context) ([]domain.Comment, error) {
// 	               panic("mock out the Fetch method")
//             },
//             FetchByTaskIDFunc: func(ctx context.Context, id uuid.UUID) ([]domain.Comment, error) {
// 	               panic("mock out the FetchByTaskID method")
//             },
//             GetByIDFunc: func(ctx context.Context, id uuid.UUID) (domain.Comment, error) {
// 	               panic("mock out the GetByID method")
//             },
//             StoreFunc: func(ctx context.Context, ct *domain.Comment) error {
// 	               panic("mock out the Store method")
//             },
//             UpdateFunc: func(ctx context.Context, cm *domain.Comment) error {
// 	               panic("mock out the Update method")
//             },
//         }
//
//         // use mockedCommentRepository in code that requires domain.CommentRepository
//         // and then make assertions.
//
//     }
type CommentRepositoryMock struct {
	// DeleteFunc mocks the Delete method.
	DeleteFunc func(ctx context.Context, id uuid.UUID) error

	// FetchFunc mocks the Fetch method.
	FetchFunc func(ctx context.Context) ([]domain.Comment, error)

	// FetchByTaskIDFunc mocks the FetchByTaskID method.
	FetchByTaskIDFunc func(ctx context.Context, id uuid.UUID) ([]domain.Comment, error)

	// GetByIDFunc mocks the GetByID method.
	GetByIDFunc func(ctx context.Context, id uuid.UUID) (domain.Comment, error)

	// StoreFunc mocks the Store method.
	StoreFunc func(ctx context.Context, ct *domain.Comment) error

	// UpdateFunc mocks the Update method.
	UpdateFunc func(ctx context.Context, cm *domain.Comment) error

	// calls tracks calls to the methods.
	calls struct {
		// Delete holds details about calls to the Delete method.
		Delete []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID uuid.UUID
		}
		// Fetch holds details about calls to the Fetch method.
		Fetch []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// FetchByTaskID holds details about calls to the FetchByTaskID method.
		FetchByTaskID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID uuid.UUID
		}
		// GetByID holds details about calls to the GetByID method.
		GetByID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID uuid.UUID
		}
		// Store holds details about calls to the Store method.
		Store []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Ct is the ct argument value.
			Ct *domain.Comment
		}
		// Update holds details about calls to the Update method.
		Update []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Cm is the cm argument value.
			Cm *domain.Comment
		}
	}
	lockDelete        sync.RWMutex
	lockFetch         sync.RWMutex
	lockFetchByTaskID sync.RWMutex
	lockGetByID       sync.RWMutex
	lockStore         sync.RWMutex
	lockUpdate        sync.RWMutex
}

// Delete calls DeleteFunc.
func (mock *CommentRepositoryMock) Delete(ctx context.Context, id uuid.UUID) error {
	if mock.DeleteFunc == nil {
		panic("CommentRepositoryMock.DeleteFunc: method is nil but CommentRepository.Delete was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  uuid.UUID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockDelete.Lock()
	mock.calls.Delete = append(mock.calls.Delete, callInfo)
	mock.lockDelete.Unlock()
	return mock.DeleteFunc(ctx, id)
}

// DeleteCalls gets all the calls that were made to Delete.
// Check the length with:
//     len(mockedCommentRepository.DeleteCalls())
func (mock *CommentRepositoryMock) DeleteCalls() []struct {
	Ctx context.Context
	ID  uuid.UUID
} {
	var calls []struct {
		Ctx context.Context
		ID  uuid.UUID
	}
	mock.lockDelete.RLock()
	calls = mock.calls.Delete
	mock.lockDelete.RUnlock()
	return calls
}

// Fetch calls FetchFunc.
func (mock *CommentRepositoryMock) Fetch(ctx context.Context) ([]domain.Comment, error) {
	if mock.FetchFunc == nil {
		panic("CommentRepositoryMock.FetchFunc: method is nil but CommentRepository.Fetch was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockFetch.Lock()
	mock.calls.Fetch = append(mock.calls.Fetch, callInfo)
	mock.lockFetch.Unlock()
	return mock.FetchFunc(ctx)
}

// FetchCalls gets all the calls that were made to Fetch.
// Check the length with:
//     len(mockedCommentRepository.FetchCalls())
func (mock *CommentRepositoryMock) FetchCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockFetch.RLock()
	calls = mock.calls.Fetch
	mock.lockFetch.RUnlock()
	return calls
}

// FetchByTaskID calls FetchByTaskIDFunc.
func (mock *CommentRepositoryMock) FetchByTaskID(ctx context.Context, id uuid.UUID) ([]domain.Comment, error) {
	if mock.FetchByTaskIDFunc == nil {
		panic("CommentRepositoryMock.FetchByTaskIDFunc: method is nil but CommentRepository.FetchByTaskID was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  uuid.UUID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockFetchByTaskID.Lock()
	mock.calls.FetchByTaskID = append(mock.calls.FetchByTaskID, callInfo)
	mock.lockFetchByTaskID.Unlock()
	return mock.FetchByTaskIDFunc(ctx, id)
}

// FetchByTaskIDCalls gets all the calls that were made to FetchByTaskID.
// Check the length with:
//     len(mockedCommentRepository.FetchByTaskIDCalls())
func (mock *CommentRepositoryMock) FetchByTaskIDCalls() []struct {
	Ctx context.Context
	ID  uuid.UUID
} {
	var calls []struct {
		Ctx context.Context
		ID  uuid.UUID
	}
	mock.lockFetchByTaskID.RLock()
	calls = mock.calls.FetchByTaskID
	mock.lockFetchByTaskID.RUnlock()
	return calls
}

// GetByID calls GetByIDFunc.
func (mock *CommentRepositoryMock) GetByID(ctx context.Context, id uuid.UUID) (domain.Comment, error) {
	if mock.GetByIDFunc == nil {
		panic("CommentRepositoryMock.GetByIDFunc: method is nil but CommentRepository.GetByID was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  uuid.UUID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockGetByID.Lock()
	mock.calls.GetByID = append(mock.calls.GetByID, callInfo)
	mock.lockGetByID.Unlock()
	return mock.GetByIDFunc(ctx, id)
}

// GetByIDCalls gets all the calls that were made to GetByID.
// Check the length with:
//     len(mockedCommentRepository.GetByIDCalls())
func (mock *CommentRepositoryMock) GetByIDCalls() []struct {
	Ctx context.Context
	ID  uuid.UUID
} {
	var calls []struct {
		Ctx context.Context
		ID  uuid.UUID
	}
	mock.lockGetByID.RLock()
	calls = mock.calls.GetByID
	mock.lockGetByID.RUnlock()
	return calls
}

// Store calls StoreFunc.
func (mock *CommentRepositoryMock) Store(ctx context.Context, ct *domain.Comment) error {
	if mock.StoreFunc == nil {
		panic("CommentRepositoryMock.StoreFunc: method is nil but CommentRepository.Store was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Ct  *domain.Comment
	}{
		Ctx: ctx,
		Ct:  ct,
	}
	mock.lockStore.Lock()
	mock.calls.Store = append(mock.calls.Store, callInfo)
	mock.lockStore.Unlock()
	return mock.StoreFunc(ctx, ct)
}

// StoreCalls gets all the calls that were made to Store.
// Check the length with:
//     len(mockedCommentRepository.StoreCalls())
func (mock *CommentRepositoryMock) StoreCalls() []struct {
	Ctx context.Context
	Ct  *domain.Comment
} {
	var calls []struct {
		Ctx context.Context
		Ct  *domain.Comment
	}
	mock.lockStore.RLock()
	calls = mock.calls.Store
	mock.lockStore.RUnlock()
	return calls
}

// Update calls UpdateFunc.
func (mock *CommentRepositoryMock) Update(ctx context.Context, cm *domain.Comment) error {
	if mock.UpdateFunc == nil {
		panic("CommentRepositoryMock.UpdateFunc: method is nil but CommentRepository.Update was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Cm  *domain.Comment
	}{
		Ctx: ctx,
		Cm:  cm,
	}
	mock.lockUpdate.Lock()
	mock.calls.Update = append(mock.calls.Update, callInfo)
	mock.lockUpdate.Unlock()
	return mock.UpdateFunc(ctx, cm)
}

// UpdateCalls gets all the calls that were made to Update.
// Check the length with:
//     len(mockedCommentRepository.UpdateCalls())
func (mock *CommentRepositoryMock) UpdateCalls() []struct {
	Ctx context.Context
	Cm  *domain.Comment
} {
	var calls []struct {
		Ctx context.Context
		Cm  *domain.Comment
	}
	mock.lockUpdate.RLock()
	calls = mock.calls.Update
	mock.lockUpdate.RUnlock()
	return calls
}
