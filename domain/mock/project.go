// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"context"
	"github.com/google/uuid"
	"github.com/igkostyuk/tasktracker/domain"
	"sync"
)

// Ensure, that ProjectUsecaseMock does implement domain.ProjectUsecase.
// If this is not the case, regenerate this file with moq.
var _ domain.ProjectUsecase = &ProjectUsecaseMock{}

// ProjectUsecaseMock is a mock implementation of domain.ProjectUsecase.
//
//     func TestSomethingThatUsesProjectUsecase(t *testing.T) {
//
//         // make and configure a mocked domain.ProjectUsecase
//         mockedProjectUsecase := &ProjectUsecaseMock{
//             DeleteFunc: func(ctx context.Context, id uuid.UUID) error {
// 	               panic("mock out the Delete method")
//             },
//             FetchFunc: func(ctx context.Context) ([]domain.Project, error) {
// 	               panic("mock out the Fetch method")
//             },
//             FetchColumnsFunc: func(ctx context.Context, id uuid.UUID) ([]domain.Column, error) {
// 	               panic("mock out the FetchColumns method")
//             },
//             FetchTasksFunc: func(ctx context.Context, id uuid.UUID) ([]domain.Task, error) {
// 	               panic("mock out the FetchTasks method")
//             },
//             GetByIDFunc: func(ctx context.Context, id uuid.UUID) (domain.Project, error) {
// 	               panic("mock out the GetByID method")
//             },
//             StoreFunc: func(in1 context.Context, in2 *domain.Project) error {
// 	               panic("mock out the Store method")
//             },
//             StoreColumnFunc: func(in1 context.Context, in2 *domain.Column) error {
// 	               panic("mock out the StoreColumn method")
//             },
//             UpdateFunc: func(ctx context.Context, pr *domain.Project) error {
// 	               panic("mock out the Update method")
//             },
//         }
//
//         // use mockedProjectUsecase in code that requires domain.ProjectUsecase
//         // and then make assertions.
//
//     }
type ProjectUsecaseMock struct {
	// DeleteFunc mocks the Delete method.
	DeleteFunc func(ctx context.Context, id uuid.UUID) error

	// FetchFunc mocks the Fetch method.
	FetchFunc func(ctx context.Context) ([]domain.Project, error)

	// FetchColumnsFunc mocks the FetchColumns method.
	FetchColumnsFunc func(ctx context.Context, id uuid.UUID) ([]domain.Column, error)

	// FetchTasksFunc mocks the FetchTasks method.
	FetchTasksFunc func(ctx context.Context, id uuid.UUID) ([]domain.Task, error)

	// GetByIDFunc mocks the GetByID method.
	GetByIDFunc func(ctx context.Context, id uuid.UUID) (domain.Project, error)

	// StoreFunc mocks the Store method.
	StoreFunc func(in1 context.Context, in2 *domain.Project) error

	// StoreColumnFunc mocks the StoreColumn method.
	StoreColumnFunc func(in1 context.Context, in2 *domain.Column) error

	// UpdateFunc mocks the Update method.
	UpdateFunc func(ctx context.Context, pr *domain.Project) error

	// calls tracks calls to the methods.
	calls struct {
		// Delete holds details about calls to the Delete method.
		Delete []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID uuid.UUID
		}
		// Fetch holds details about calls to the Fetch method.
		Fetch []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// FetchColumns holds details about calls to the FetchColumns method.
		FetchColumns []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID uuid.UUID
		}
		// FetchTasks holds details about calls to the FetchTasks method.
		FetchTasks []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID uuid.UUID
		}
		// GetByID holds details about calls to the GetByID method.
		GetByID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID uuid.UUID
		}
		// Store holds details about calls to the Store method.
		Store []struct {
			// In1 is the in1 argument value.
			In1 context.Context
			// In2 is the in2 argument value.
			In2 *domain.Project
		}
		// StoreColumn holds details about calls to the StoreColumn method.
		StoreColumn []struct {
			// In1 is the in1 argument value.
			In1 context.Context
			// In2 is the in2 argument value.
			In2 *domain.Column
		}
		// Update holds details about calls to the Update method.
		Update []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Pr is the pr argument value.
			Pr *domain.Project
		}
	}
	lockDelete       sync.RWMutex
	lockFetch        sync.RWMutex
	lockFetchColumns sync.RWMutex
	lockFetchTasks   sync.RWMutex
	lockGetByID      sync.RWMutex
	lockStore        sync.RWMutex
	lockStoreColumn  sync.RWMutex
	lockUpdate       sync.RWMutex
}

// Delete calls DeleteFunc.
func (mock *ProjectUsecaseMock) Delete(ctx context.Context, id uuid.UUID) error {
	if mock.DeleteFunc == nil {
		panic("ProjectUsecaseMock.DeleteFunc: method is nil but ProjectUsecase.Delete was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  uuid.UUID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockDelete.Lock()
	mock.calls.Delete = append(mock.calls.Delete, callInfo)
	mock.lockDelete.Unlock()
	return mock.DeleteFunc(ctx, id)
}

// DeleteCalls gets all the calls that were made to Delete.
// Check the length with:
//     len(mockedProjectUsecase.DeleteCalls())
func (mock *ProjectUsecaseMock) DeleteCalls() []struct {
	Ctx context.Context
	ID  uuid.UUID
} {
	var calls []struct {
		Ctx context.Context
		ID  uuid.UUID
	}
	mock.lockDelete.RLock()
	calls = mock.calls.Delete
	mock.lockDelete.RUnlock()
	return calls
}

// Fetch calls FetchFunc.
func (mock *ProjectUsecaseMock) Fetch(ctx context.Context) ([]domain.Project, error) {
	if mock.FetchFunc == nil {
		panic("ProjectUsecaseMock.FetchFunc: method is nil but ProjectUsecase.Fetch was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockFetch.Lock()
	mock.calls.Fetch = append(mock.calls.Fetch, callInfo)
	mock.lockFetch.Unlock()
	return mock.FetchFunc(ctx)
}

// FetchCalls gets all the calls that were made to Fetch.
// Check the length with:
//     len(mockedProjectUsecase.FetchCalls())
func (mock *ProjectUsecaseMock) FetchCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockFetch.RLock()
	calls = mock.calls.Fetch
	mock.lockFetch.RUnlock()
	return calls
}

// FetchColumns calls FetchColumnsFunc.
func (mock *ProjectUsecaseMock) FetchColumns(ctx context.Context, id uuid.UUID) ([]domain.Column, error) {
	if mock.FetchColumnsFunc == nil {
		panic("ProjectUsecaseMock.FetchColumnsFunc: method is nil but ProjectUsecase.FetchColumns was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  uuid.UUID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockFetchColumns.Lock()
	mock.calls.FetchColumns = append(mock.calls.FetchColumns, callInfo)
	mock.lockFetchColumns.Unlock()
	return mock.FetchColumnsFunc(ctx, id)
}

// FetchColumnsCalls gets all the calls that were made to FetchColumns.
// Check the length with:
//     len(mockedProjectUsecase.FetchColumnsCalls())
func (mock *ProjectUsecaseMock) FetchColumnsCalls() []struct {
	Ctx context.Context
	ID  uuid.UUID
} {
	var calls []struct {
		Ctx context.Context
		ID  uuid.UUID
	}
	mock.lockFetchColumns.RLock()
	calls = mock.calls.FetchColumns
	mock.lockFetchColumns.RUnlock()
	return calls
}

// FetchTasks calls FetchTasksFunc.
func (mock *ProjectUsecaseMock) FetchTasks(ctx context.Context, id uuid.UUID) ([]domain.Task, error) {
	if mock.FetchTasksFunc == nil {
		panic("ProjectUsecaseMock.FetchTasksFunc: method is nil but ProjectUsecase.FetchTasks was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  uuid.UUID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockFetchTasks.Lock()
	mock.calls.FetchTasks = append(mock.calls.FetchTasks, callInfo)
	mock.lockFetchTasks.Unlock()
	return mock.FetchTasksFunc(ctx, id)
}

// FetchTasksCalls gets all the calls that were made to FetchTasks.
// Check the length with:
//     len(mockedProjectUsecase.FetchTasksCalls())
func (mock *ProjectUsecaseMock) FetchTasksCalls() []struct {
	Ctx context.Context
	ID  uuid.UUID
} {
	var calls []struct {
		Ctx context.Context
		ID  uuid.UUID
	}
	mock.lockFetchTasks.RLock()
	calls = mock.calls.FetchTasks
	mock.lockFetchTasks.RUnlock()
	return calls
}

// GetByID calls GetByIDFunc.
func (mock *ProjectUsecaseMock) GetByID(ctx context.Context, id uuid.UUID) (domain.Project, error) {
	if mock.GetByIDFunc == nil {
		panic("ProjectUsecaseMock.GetByIDFunc: method is nil but ProjectUsecase.GetByID was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  uuid.UUID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockGetByID.Lock()
	mock.calls.GetByID = append(mock.calls.GetByID, callInfo)
	mock.lockGetByID.Unlock()
	return mock.GetByIDFunc(ctx, id)
}

// GetByIDCalls gets all the calls that were made to GetByID.
// Check the length with:
//     len(mockedProjectUsecase.GetByIDCalls())
func (mock *ProjectUsecaseMock) GetByIDCalls() []struct {
	Ctx context.Context
	ID  uuid.UUID
} {
	var calls []struct {
		Ctx context.Context
		ID  uuid.UUID
	}
	mock.lockGetByID.RLock()
	calls = mock.calls.GetByID
	mock.lockGetByID.RUnlock()
	return calls
}

// Store calls StoreFunc.
func (mock *ProjectUsecaseMock) Store(in1 context.Context, in2 *domain.Project) error {
	if mock.StoreFunc == nil {
		panic("ProjectUsecaseMock.StoreFunc: method is nil but ProjectUsecase.Store was just called")
	}
	callInfo := struct {
		In1 context.Context
		In2 *domain.Project
	}{
		In1: in1,
		In2: in2,
	}
	mock.lockStore.Lock()
	mock.calls.Store = append(mock.calls.Store, callInfo)
	mock.lockStore.Unlock()
	return mock.StoreFunc(in1, in2)
}

// StoreCalls gets all the calls that were made to Store.
// Check the length with:
//     len(mockedProjectUsecase.StoreCalls())
func (mock *ProjectUsecaseMock) StoreCalls() []struct {
	In1 context.Context
	In2 *domain.Project
} {
	var calls []struct {
		In1 context.Context
		In2 *domain.Project
	}
	mock.lockStore.RLock()
	calls = mock.calls.Store
	mock.lockStore.RUnlock()
	return calls
}

// StoreColumn calls StoreColumnFunc.
func (mock *ProjectUsecaseMock) StoreColumn(in1 context.Context, in2 *domain.Column) error {
	if mock.StoreColumnFunc == nil {
		panic("ProjectUsecaseMock.StoreColumnFunc: method is nil but ProjectUsecase.StoreColumn was just called")
	}
	callInfo := struct {
		In1 context.Context
		In2 *domain.Column
	}{
		In1: in1,
		In2: in2,
	}
	mock.lockStoreColumn.Lock()
	mock.calls.StoreColumn = append(mock.calls.StoreColumn, callInfo)
	mock.lockStoreColumn.Unlock()
	return mock.StoreColumnFunc(in1, in2)
}

// StoreColumnCalls gets all the calls that were made to StoreColumn.
// Check the length with:
//     len(mockedProjectUsecase.StoreColumnCalls())
func (mock *ProjectUsecaseMock) StoreColumnCalls() []struct {
	In1 context.Context
	In2 *domain.Column
} {
	var calls []struct {
		In1 context.Context
		In2 *domain.Column
	}
	mock.lockStoreColumn.RLock()
	calls = mock.calls.StoreColumn
	mock.lockStoreColumn.RUnlock()
	return calls
}

// Update calls UpdateFunc.
func (mock *ProjectUsecaseMock) Update(ctx context.Context, pr *domain.Project) error {
	if mock.UpdateFunc == nil {
		panic("ProjectUsecaseMock.UpdateFunc: method is nil but ProjectUsecase.Update was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Pr  *domain.Project
	}{
		Ctx: ctx,
		Pr:  pr,
	}
	mock.lockUpdate.Lock()
	mock.calls.Update = append(mock.calls.Update, callInfo)
	mock.lockUpdate.Unlock()
	return mock.UpdateFunc(ctx, pr)
}

// UpdateCalls gets all the calls that were made to Update.
// Check the length with:
//     len(mockedProjectUsecase.UpdateCalls())
func (mock *ProjectUsecaseMock) UpdateCalls() []struct {
	Ctx context.Context
	Pr  *domain.Project
} {
	var calls []struct {
		Ctx context.Context
		Pr  *domain.Project
	}
	mock.lockUpdate.RLock()
	calls = mock.calls.Update
	mock.lockUpdate.RUnlock()
	return calls
}

// Ensure, that ProjectRepositoryMock does implement domain.ProjectRepository.
// If this is not the case, regenerate this file with moq.
var _ domain.ProjectRepository = &ProjectRepositoryMock{}

// ProjectRepositoryMock is a mock implementation of domain.ProjectRepository.
//
//     func TestSomethingThatUsesProjectRepository(t *testing.T) {
//
//         // make and configure a mocked domain.ProjectRepository
//         mockedProjectRepository := &ProjectRepositoryMock{
//             DeleteFunc: func(ctx context.Context, id uuid.UUID) error {
// 	               panic("mock out the Delete method")
//             },
//             FetchFunc: func(ctx context.Context) ([]domain.Project, error) {
// 	               panic("mock out the Fetch method")
//             },
//             GetByIDFunc: func(ctx context.Context, id uuid.UUID) (domain.Project, error) {
// 	               panic("mock out the GetByID method")
//             },
//             StoreFunc: func(ctx context.Context, a *domain.Project) error {
// 	               panic("mock out the Store method")
//             },
//             UpdateFunc: func(ctx context.Context, pr *domain.Project) error {
// 	               panic("mock out the Update method")
//             },
//         }
//
//         // use mockedProjectRepository in code that requires domain.ProjectRepository
//         // and then make assertions.
//
//     }
type ProjectRepositoryMock struct {
	// DeleteFunc mocks the Delete method.
	DeleteFunc func(ctx context.Context, id uuid.UUID) error

	// FetchFunc mocks the Fetch method.
	FetchFunc func(ctx context.Context) ([]domain.Project, error)

	// GetByIDFunc mocks the GetByID method.
	GetByIDFunc func(ctx context.Context, id uuid.UUID) (domain.Project, error)

	// StoreFunc mocks the Store method.
	StoreFunc func(ctx context.Context, a *domain.Project) error

	// UpdateFunc mocks the Update method.
	UpdateFunc func(ctx context.Context, pr *domain.Project) error

	// calls tracks calls to the methods.
	calls struct {
		// Delete holds details about calls to the Delete method.
		Delete []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID uuid.UUID
		}
		// Fetch holds details about calls to the Fetch method.
		Fetch []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// GetByID holds details about calls to the GetByID method.
		GetByID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID uuid.UUID
		}
		// Store holds details about calls to the Store method.
		Store []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// A is the a argument value.
			A *domain.Project
		}
		// Update holds details about calls to the Update method.
		Update []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Pr is the pr argument value.
			Pr *domain.Project
		}
	}
	lockDelete  sync.RWMutex
	lockFetch   sync.RWMutex
	lockGetByID sync.RWMutex
	lockStore   sync.RWMutex
	lockUpdate  sync.RWMutex
}

// Delete calls DeleteFunc.
func (mock *ProjectRepositoryMock) Delete(ctx context.Context, id uuid.UUID) error {
	if mock.DeleteFunc == nil {
		panic("ProjectRepositoryMock.DeleteFunc: method is nil but ProjectRepository.Delete was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  uuid.UUID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockDelete.Lock()
	mock.calls.Delete = append(mock.calls.Delete, callInfo)
	mock.lockDelete.Unlock()
	return mock.DeleteFunc(ctx, id)
}

// DeleteCalls gets all the calls that were made to Delete.
// Check the length with:
//     len(mockedProjectRepository.DeleteCalls())
func (mock *ProjectRepositoryMock) DeleteCalls() []struct {
	Ctx context.Context
	ID  uuid.UUID
} {
	var calls []struct {
		Ctx context.Context
		ID  uuid.UUID
	}
	mock.lockDelete.RLock()
	calls = mock.calls.Delete
	mock.lockDelete.RUnlock()
	return calls
}

// Fetch calls FetchFunc.
func (mock *ProjectRepositoryMock) Fetch(ctx context.Context) ([]domain.Project, error) {
	if mock.FetchFunc == nil {
		panic("ProjectRepositoryMock.FetchFunc: method is nil but ProjectRepository.Fetch was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockFetch.Lock()
	mock.calls.Fetch = append(mock.calls.Fetch, callInfo)
	mock.lockFetch.Unlock()
	return mock.FetchFunc(ctx)
}

// FetchCalls gets all the calls that were made to Fetch.
// Check the length with:
//     len(mockedProjectRepository.FetchCalls())
func (mock *ProjectRepositoryMock) FetchCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockFetch.RLock()
	calls = mock.calls.Fetch
	mock.lockFetch.RUnlock()
	return calls
}

// GetByID calls GetByIDFunc.
func (mock *ProjectRepositoryMock) GetByID(ctx context.Context, id uuid.UUID) (domain.Project, error) {
	if mock.GetByIDFunc == nil {
		panic("ProjectRepositoryMock.GetByIDFunc: method is nil but ProjectRepository.GetByID was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  uuid.UUID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockGetByID.Lock()
	mock.calls.GetByID = append(mock.calls.GetByID, callInfo)
	mock.lockGetByID.Unlock()
	return mock.GetByIDFunc(ctx, id)
}

// GetByIDCalls gets all the calls that were made to GetByID.
// Check the length with:
//     len(mockedProjectRepository.GetByIDCalls())
func (mock *ProjectRepositoryMock) GetByIDCalls() []struct {
	Ctx context.Context
	ID  uuid.UUID
} {
	var calls []struct {
		Ctx context.Context
		ID  uuid.UUID
	}
	mock.lockGetByID.RLock()
	calls = mock.calls.GetByID
	mock.lockGetByID.RUnlock()
	return calls
}

// Store calls StoreFunc.
func (mock *ProjectRepositoryMock) Store(ctx context.Context, a *domain.Project) error {
	if mock.StoreFunc == nil {
		panic("ProjectRepositoryMock.StoreFunc: method is nil but ProjectRepository.Store was just called")
	}
	callInfo := struct {
		Ctx context.Context
		A   *domain.Project
	}{
		Ctx: ctx,
		A:   a,
	}
	mock.lockStore.Lock()
	mock.calls.Store = append(mock.calls.Store, callInfo)
	mock.lockStore.Unlock()
	return mock.StoreFunc(ctx, a)
}

// StoreCalls gets all the calls that were made to Store.
// Check the length with:
//     len(mockedProjectRepository.StoreCalls())
func (mock *ProjectRepositoryMock) StoreCalls() []struct {
	Ctx context.Context
	A   *domain.Project
} {
	var calls []struct {
		Ctx context.Context
		A   *domain.Project
	}
	mock.lockStore.RLock()
	calls = mock.calls.Store
	mock.lockStore.RUnlock()
	return calls
}

// Update calls UpdateFunc.
func (mock *ProjectRepositoryMock) Update(ctx context.Context, pr *domain.Project) error {
	if mock.UpdateFunc == nil {
		panic("ProjectRepositoryMock.UpdateFunc: method is nil but ProjectRepository.Update was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Pr  *domain.Project
	}{
		Ctx: ctx,
		Pr:  pr,
	}
	mock.lockUpdate.Lock()
	mock.calls.Update = append(mock.calls.Update, callInfo)
	mock.lockUpdate.Unlock()
	return mock.UpdateFunc(ctx, pr)
}

// UpdateCalls gets all the calls that were made to Update.
// Check the length with:
//     len(mockedProjectRepository.UpdateCalls())
func (mock *ProjectRepositoryMock) UpdateCalls() []struct {
	Ctx context.Context
	Pr  *domain.Project
} {
	var calls []struct {
		Ctx context.Context
		Pr  *domain.Project
	}
	mock.lockUpdate.RLock()
	calls = mock.calls.Update
	mock.lockUpdate.RUnlock()
	return calls
}
