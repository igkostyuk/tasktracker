// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"context"
	"github.com/google/uuid"
	"github.com/igkostyuk/tasktracker/domain"
	"sync"
)

// Ensure, that TaskUsecaseMock does implement domain.TaskUsecase.
// If this is not the case, regenerate this file with moq.
var _ domain.TaskUsecase = &TaskUsecaseMock{}

// TaskUsecaseMock is a mock implementation of domain.TaskUsecase.
//
//     func TestSomethingThatUsesTaskUsecase(t *testing.T) {
//
//         // make and configure a mocked domain.TaskUsecase
//         mockedTaskUsecase := &TaskUsecaseMock{
//             DeleteFunc: func(ctx context.Context, id uuid.UUID) error {
// 	               panic("mock out the Delete method")
//             },
//             FetchFunc: func(ctx context.Context) ([]domain.Task, error) {
// 	               panic("mock out the Fetch method")
//             },
//             FetchByColumnIDFunc: func(ctx context.Context, id uuid.UUID) ([]domain.Task, error) {
// 	               panic("mock out the FetchByColumnID method")
//             },
//             FetchByProjectIDFunc: func(ctx context.Context, id uuid.UUID) ([]domain.Task, error) {
// 	               panic("mock out the FetchByProjectID method")
//             },
//             FetchCommentsFunc: func(ctx context.Context, id uuid.UUID) ([]domain.Comment, error) {
// 	               panic("mock out the FetchComments method")
//             },
//             GetByIDFunc: func(ctx context.Context, id uuid.UUID) (domain.Task, error) {
// 	               panic("mock out the GetByID method")
//             },
//             StoreFunc: func(in1 context.Context, in2 *domain.Task) error {
// 	               panic("mock out the Store method")
//             },
//             UpdateFunc: func(ctx context.Context, tk *domain.Task) error {
// 	               panic("mock out the Update method")
//             },
//         }
//
//         // use mockedTaskUsecase in code that requires domain.TaskUsecase
//         // and then make assertions.
//
//     }
type TaskUsecaseMock struct {
	// DeleteFunc mocks the Delete method.
	DeleteFunc func(ctx context.Context, id uuid.UUID) error

	// FetchFunc mocks the Fetch method.
	FetchFunc func(ctx context.Context) ([]domain.Task, error)

	// FetchByColumnIDFunc mocks the FetchByColumnID method.
	FetchByColumnIDFunc func(ctx context.Context, id uuid.UUID) ([]domain.Task, error)

	// FetchByProjectIDFunc mocks the FetchByProjectID method.
	FetchByProjectIDFunc func(ctx context.Context, id uuid.UUID) ([]domain.Task, error)

	// FetchCommentsFunc mocks the FetchComments method.
	FetchCommentsFunc func(ctx context.Context, id uuid.UUID) ([]domain.Comment, error)

	// GetByIDFunc mocks the GetByID method.
	GetByIDFunc func(ctx context.Context, id uuid.UUID) (domain.Task, error)

	// StoreFunc mocks the Store method.
	StoreFunc func(in1 context.Context, in2 *domain.Task) error

	// UpdateFunc mocks the Update method.
	UpdateFunc func(ctx context.Context, tk *domain.Task) error

	// calls tracks calls to the methods.
	calls struct {
		// Delete holds details about calls to the Delete method.
		Delete []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID uuid.UUID
		}
		// Fetch holds details about calls to the Fetch method.
		Fetch []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// FetchByColumnID holds details about calls to the FetchByColumnID method.
		FetchByColumnID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID uuid.UUID
		}
		// FetchByProjectID holds details about calls to the FetchByProjectID method.
		FetchByProjectID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID uuid.UUID
		}
		// FetchComments holds details about calls to the FetchComments method.
		FetchComments []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID uuid.UUID
		}
		// GetByID holds details about calls to the GetByID method.
		GetByID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID uuid.UUID
		}
		// Store holds details about calls to the Store method.
		Store []struct {
			// In1 is the in1 argument value.
			In1 context.Context
			// In2 is the in2 argument value.
			In2 *domain.Task
		}
		// Update holds details about calls to the Update method.
		Update []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Tk is the tk argument value.
			Tk *domain.Task
		}
	}
	lockDelete           sync.RWMutex
	lockFetch            sync.RWMutex
	lockFetchByColumnID  sync.RWMutex
	lockFetchByProjectID sync.RWMutex
	lockFetchComments    sync.RWMutex
	lockGetByID          sync.RWMutex
	lockStore            sync.RWMutex
	lockUpdate           sync.RWMutex
}

// Delete calls DeleteFunc.
func (mock *TaskUsecaseMock) Delete(ctx context.Context, id uuid.UUID) error {
	if mock.DeleteFunc == nil {
		panic("TaskUsecaseMock.DeleteFunc: method is nil but TaskUsecase.Delete was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  uuid.UUID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockDelete.Lock()
	mock.calls.Delete = append(mock.calls.Delete, callInfo)
	mock.lockDelete.Unlock()
	return mock.DeleteFunc(ctx, id)
}

// DeleteCalls gets all the calls that were made to Delete.
// Check the length with:
//     len(mockedTaskUsecase.DeleteCalls())
func (mock *TaskUsecaseMock) DeleteCalls() []struct {
	Ctx context.Context
	ID  uuid.UUID
} {
	var calls []struct {
		Ctx context.Context
		ID  uuid.UUID
	}
	mock.lockDelete.RLock()
	calls = mock.calls.Delete
	mock.lockDelete.RUnlock()
	return calls
}

// Fetch calls FetchFunc.
func (mock *TaskUsecaseMock) Fetch(ctx context.Context) ([]domain.Task, error) {
	if mock.FetchFunc == nil {
		panic("TaskUsecaseMock.FetchFunc: method is nil but TaskUsecase.Fetch was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockFetch.Lock()
	mock.calls.Fetch = append(mock.calls.Fetch, callInfo)
	mock.lockFetch.Unlock()
	return mock.FetchFunc(ctx)
}

// FetchCalls gets all the calls that were made to Fetch.
// Check the length with:
//     len(mockedTaskUsecase.FetchCalls())
func (mock *TaskUsecaseMock) FetchCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockFetch.RLock()
	calls = mock.calls.Fetch
	mock.lockFetch.RUnlock()
	return calls
}

// FetchByColumnID calls FetchByColumnIDFunc.
func (mock *TaskUsecaseMock) FetchByColumnID(ctx context.Context, id uuid.UUID) ([]domain.Task, error) {
	if mock.FetchByColumnIDFunc == nil {
		panic("TaskUsecaseMock.FetchByColumnIDFunc: method is nil but TaskUsecase.FetchByColumnID was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  uuid.UUID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockFetchByColumnID.Lock()
	mock.calls.FetchByColumnID = append(mock.calls.FetchByColumnID, callInfo)
	mock.lockFetchByColumnID.Unlock()
	return mock.FetchByColumnIDFunc(ctx, id)
}

// FetchByColumnIDCalls gets all the calls that were made to FetchByColumnID.
// Check the length with:
//     len(mockedTaskUsecase.FetchByColumnIDCalls())
func (mock *TaskUsecaseMock) FetchByColumnIDCalls() []struct {
	Ctx context.Context
	ID  uuid.UUID
} {
	var calls []struct {
		Ctx context.Context
		ID  uuid.UUID
	}
	mock.lockFetchByColumnID.RLock()
	calls = mock.calls.FetchByColumnID
	mock.lockFetchByColumnID.RUnlock()
	return calls
}

// FetchByProjectID calls FetchByProjectIDFunc.
func (mock *TaskUsecaseMock) FetchByProjectID(ctx context.Context, id uuid.UUID) ([]domain.Task, error) {
	if mock.FetchByProjectIDFunc == nil {
		panic("TaskUsecaseMock.FetchByProjectIDFunc: method is nil but TaskUsecase.FetchByProjectID was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  uuid.UUID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockFetchByProjectID.Lock()
	mock.calls.FetchByProjectID = append(mock.calls.FetchByProjectID, callInfo)
	mock.lockFetchByProjectID.Unlock()
	return mock.FetchByProjectIDFunc(ctx, id)
}

// FetchByProjectIDCalls gets all the calls that were made to FetchByProjectID.
// Check the length with:
//     len(mockedTaskUsecase.FetchByProjectIDCalls())
func (mock *TaskUsecaseMock) FetchByProjectIDCalls() []struct {
	Ctx context.Context
	ID  uuid.UUID
} {
	var calls []struct {
		Ctx context.Context
		ID  uuid.UUID
	}
	mock.lockFetchByProjectID.RLock()
	calls = mock.calls.FetchByProjectID
	mock.lockFetchByProjectID.RUnlock()
	return calls
}

// FetchComments calls FetchCommentsFunc.
func (mock *TaskUsecaseMock) FetchComments(ctx context.Context, id uuid.UUID) ([]domain.Comment, error) {
	if mock.FetchCommentsFunc == nil {
		panic("TaskUsecaseMock.FetchCommentsFunc: method is nil but TaskUsecase.FetchComments was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  uuid.UUID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockFetchComments.Lock()
	mock.calls.FetchComments = append(mock.calls.FetchComments, callInfo)
	mock.lockFetchComments.Unlock()
	return mock.FetchCommentsFunc(ctx, id)
}

// FetchCommentsCalls gets all the calls that were made to FetchComments.
// Check the length with:
//     len(mockedTaskUsecase.FetchCommentsCalls())
func (mock *TaskUsecaseMock) FetchCommentsCalls() []struct {
	Ctx context.Context
	ID  uuid.UUID
} {
	var calls []struct {
		Ctx context.Context
		ID  uuid.UUID
	}
	mock.lockFetchComments.RLock()
	calls = mock.calls.FetchComments
	mock.lockFetchComments.RUnlock()
	return calls
}

// GetByID calls GetByIDFunc.
func (mock *TaskUsecaseMock) GetByID(ctx context.Context, id uuid.UUID) (domain.Task, error) {
	if mock.GetByIDFunc == nil {
		panic("TaskUsecaseMock.GetByIDFunc: method is nil but TaskUsecase.GetByID was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  uuid.UUID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockGetByID.Lock()
	mock.calls.GetByID = append(mock.calls.GetByID, callInfo)
	mock.lockGetByID.Unlock()
	return mock.GetByIDFunc(ctx, id)
}

// GetByIDCalls gets all the calls that were made to GetByID.
// Check the length with:
//     len(mockedTaskUsecase.GetByIDCalls())
func (mock *TaskUsecaseMock) GetByIDCalls() []struct {
	Ctx context.Context
	ID  uuid.UUID
} {
	var calls []struct {
		Ctx context.Context
		ID  uuid.UUID
	}
	mock.lockGetByID.RLock()
	calls = mock.calls.GetByID
	mock.lockGetByID.RUnlock()
	return calls
}

// Store calls StoreFunc.
func (mock *TaskUsecaseMock) Store(in1 context.Context, in2 *domain.Task) error {
	if mock.StoreFunc == nil {
		panic("TaskUsecaseMock.StoreFunc: method is nil but TaskUsecase.Store was just called")
	}
	callInfo := struct {
		In1 context.Context
		In2 *domain.Task
	}{
		In1: in1,
		In2: in2,
	}
	mock.lockStore.Lock()
	mock.calls.Store = append(mock.calls.Store, callInfo)
	mock.lockStore.Unlock()
	return mock.StoreFunc(in1, in2)
}

// StoreCalls gets all the calls that were made to Store.
// Check the length with:
//     len(mockedTaskUsecase.StoreCalls())
func (mock *TaskUsecaseMock) StoreCalls() []struct {
	In1 context.Context
	In2 *domain.Task
} {
	var calls []struct {
		In1 context.Context
		In2 *domain.Task
	}
	mock.lockStore.RLock()
	calls = mock.calls.Store
	mock.lockStore.RUnlock()
	return calls
}

// Update calls UpdateFunc.
func (mock *TaskUsecaseMock) Update(ctx context.Context, tk *domain.Task) error {
	if mock.UpdateFunc == nil {
		panic("TaskUsecaseMock.UpdateFunc: method is nil but TaskUsecase.Update was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Tk  *domain.Task
	}{
		Ctx: ctx,
		Tk:  tk,
	}
	mock.lockUpdate.Lock()
	mock.calls.Update = append(mock.calls.Update, callInfo)
	mock.lockUpdate.Unlock()
	return mock.UpdateFunc(ctx, tk)
}

// UpdateCalls gets all the calls that were made to Update.
// Check the length with:
//     len(mockedTaskUsecase.UpdateCalls())
func (mock *TaskUsecaseMock) UpdateCalls() []struct {
	Ctx context.Context
	Tk  *domain.Task
} {
	var calls []struct {
		Ctx context.Context
		Tk  *domain.Task
	}
	mock.lockUpdate.RLock()
	calls = mock.calls.Update
	mock.lockUpdate.RUnlock()
	return calls
}

// Ensure, that TaskRepositoryMock does implement domain.TaskRepository.
// If this is not the case, regenerate this file with moq.
var _ domain.TaskRepository = &TaskRepositoryMock{}

// TaskRepositoryMock is a mock implementation of domain.TaskRepository.
//
//     func TestSomethingThatUsesTaskRepository(t *testing.T) {
//
//         // make and configure a mocked domain.TaskRepository
//         mockedTaskRepository := &TaskRepositoryMock{
//             DeleteFunc: func(ctx context.Context, id uuid.UUID) error {
// 	               panic("mock out the Delete method")
//             },
//             FetchFunc: func(ctx context.Context) ([]domain.Task, error) {
// 	               panic("mock out the Fetch method")
//             },
//             FetchByColumnIDFunc: func(ctx context.Context, id uuid.UUID) ([]domain.Task, error) {
// 	               panic("mock out the FetchByColumnID method")
//             },
//             FetchByProjectIDFunc: func(ctx context.Context, id uuid.UUID) ([]domain.Task, error) {
// 	               panic("mock out the FetchByProjectID method")
//             },
//             GetByIDFunc: func(ctx context.Context, id uuid.UUID) (domain.Task, error) {
// 	               panic("mock out the GetByID method")
//             },
//             StoreFunc: func(ctx context.Context, t *domain.Task) error {
// 	               panic("mock out the Store method")
//             },
//             UpdateFunc: func(ctx context.Context, tk *domain.Task) error {
// 	               panic("mock out the Update method")
//             },
//         }
//
//         // use mockedTaskRepository in code that requires domain.TaskRepository
//         // and then make assertions.
//
//     }
type TaskRepositoryMock struct {
	// DeleteFunc mocks the Delete method.
	DeleteFunc func(ctx context.Context, id uuid.UUID) error

	// FetchFunc mocks the Fetch method.
	FetchFunc func(ctx context.Context) ([]domain.Task, error)

	// FetchByColumnIDFunc mocks the FetchByColumnID method.
	FetchByColumnIDFunc func(ctx context.Context, id uuid.UUID) ([]domain.Task, error)

	// FetchByProjectIDFunc mocks the FetchByProjectID method.
	FetchByProjectIDFunc func(ctx context.Context, id uuid.UUID) ([]domain.Task, error)

	// GetByIDFunc mocks the GetByID method.
	GetByIDFunc func(ctx context.Context, id uuid.UUID) (domain.Task, error)

	// StoreFunc mocks the Store method.
	StoreFunc func(ctx context.Context, t *domain.Task) error

	// UpdateFunc mocks the Update method.
	UpdateFunc func(ctx context.Context, tk *domain.Task) error

	// calls tracks calls to the methods.
	calls struct {
		// Delete holds details about calls to the Delete method.
		Delete []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID uuid.UUID
		}
		// Fetch holds details about calls to the Fetch method.
		Fetch []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// FetchByColumnID holds details about calls to the FetchByColumnID method.
		FetchByColumnID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID uuid.UUID
		}
		// FetchByProjectID holds details about calls to the FetchByProjectID method.
		FetchByProjectID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID uuid.UUID
		}
		// GetByID holds details about calls to the GetByID method.
		GetByID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID uuid.UUID
		}
		// Store holds details about calls to the Store method.
		Store []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// T is the t argument value.
			T *domain.Task
		}
		// Update holds details about calls to the Update method.
		Update []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Tk is the tk argument value.
			Tk *domain.Task
		}
	}
	lockDelete           sync.RWMutex
	lockFetch            sync.RWMutex
	lockFetchByColumnID  sync.RWMutex
	lockFetchByProjectID sync.RWMutex
	lockGetByID          sync.RWMutex
	lockStore            sync.RWMutex
	lockUpdate           sync.RWMutex
}

// Delete calls DeleteFunc.
func (mock *TaskRepositoryMock) Delete(ctx context.Context, id uuid.UUID) error {
	if mock.DeleteFunc == nil {
		panic("TaskRepositoryMock.DeleteFunc: method is nil but TaskRepository.Delete was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  uuid.UUID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockDelete.Lock()
	mock.calls.Delete = append(mock.calls.Delete, callInfo)
	mock.lockDelete.Unlock()
	return mock.DeleteFunc(ctx, id)
}

// DeleteCalls gets all the calls that were made to Delete.
// Check the length with:
//     len(mockedTaskRepository.DeleteCalls())
func (mock *TaskRepositoryMock) DeleteCalls() []struct {
	Ctx context.Context
	ID  uuid.UUID
} {
	var calls []struct {
		Ctx context.Context
		ID  uuid.UUID
	}
	mock.lockDelete.RLock()
	calls = mock.calls.Delete
	mock.lockDelete.RUnlock()
	return calls
}

// Fetch calls FetchFunc.
func (mock *TaskRepositoryMock) Fetch(ctx context.Context) ([]domain.Task, error) {
	if mock.FetchFunc == nil {
		panic("TaskRepositoryMock.FetchFunc: method is nil but TaskRepository.Fetch was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockFetch.Lock()
	mock.calls.Fetch = append(mock.calls.Fetch, callInfo)
	mock.lockFetch.Unlock()
	return mock.FetchFunc(ctx)
}

// FetchCalls gets all the calls that were made to Fetch.
// Check the length with:
//     len(mockedTaskRepository.FetchCalls())
func (mock *TaskRepositoryMock) FetchCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockFetch.RLock()
	calls = mock.calls.Fetch
	mock.lockFetch.RUnlock()
	return calls
}

// FetchByColumnID calls FetchByColumnIDFunc.
func (mock *TaskRepositoryMock) FetchByColumnID(ctx context.Context, id uuid.UUID) ([]domain.Task, error) {
	if mock.FetchByColumnIDFunc == nil {
		panic("TaskRepositoryMock.FetchByColumnIDFunc: method is nil but TaskRepository.FetchByColumnID was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  uuid.UUID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockFetchByColumnID.Lock()
	mock.calls.FetchByColumnID = append(mock.calls.FetchByColumnID, callInfo)
	mock.lockFetchByColumnID.Unlock()
	return mock.FetchByColumnIDFunc(ctx, id)
}

// FetchByColumnIDCalls gets all the calls that were made to FetchByColumnID.
// Check the length with:
//     len(mockedTaskRepository.FetchByColumnIDCalls())
func (mock *TaskRepositoryMock) FetchByColumnIDCalls() []struct {
	Ctx context.Context
	ID  uuid.UUID
} {
	var calls []struct {
		Ctx context.Context
		ID  uuid.UUID
	}
	mock.lockFetchByColumnID.RLock()
	calls = mock.calls.FetchByColumnID
	mock.lockFetchByColumnID.RUnlock()
	return calls
}

// FetchByProjectID calls FetchByProjectIDFunc.
func (mock *TaskRepositoryMock) FetchByProjectID(ctx context.Context, id uuid.UUID) ([]domain.Task, error) {
	if mock.FetchByProjectIDFunc == nil {
		panic("TaskRepositoryMock.FetchByProjectIDFunc: method is nil but TaskRepository.FetchByProjectID was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  uuid.UUID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockFetchByProjectID.Lock()
	mock.calls.FetchByProjectID = append(mock.calls.FetchByProjectID, callInfo)
	mock.lockFetchByProjectID.Unlock()
	return mock.FetchByProjectIDFunc(ctx, id)
}

// FetchByProjectIDCalls gets all the calls that were made to FetchByProjectID.
// Check the length with:
//     len(mockedTaskRepository.FetchByProjectIDCalls())
func (mock *TaskRepositoryMock) FetchByProjectIDCalls() []struct {
	Ctx context.Context
	ID  uuid.UUID
} {
	var calls []struct {
		Ctx context.Context
		ID  uuid.UUID
	}
	mock.lockFetchByProjectID.RLock()
	calls = mock.calls.FetchByProjectID
	mock.lockFetchByProjectID.RUnlock()
	return calls
}

// GetByID calls GetByIDFunc.
func (mock *TaskRepositoryMock) GetByID(ctx context.Context, id uuid.UUID) (domain.Task, error) {
	if mock.GetByIDFunc == nil {
		panic("TaskRepositoryMock.GetByIDFunc: method is nil but TaskRepository.GetByID was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  uuid.UUID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockGetByID.Lock()
	mock.calls.GetByID = append(mock.calls.GetByID, callInfo)
	mock.lockGetByID.Unlock()
	return mock.GetByIDFunc(ctx, id)
}

// GetByIDCalls gets all the calls that were made to GetByID.
// Check the length with:
//     len(mockedTaskRepository.GetByIDCalls())
func (mock *TaskRepositoryMock) GetByIDCalls() []struct {
	Ctx context.Context
	ID  uuid.UUID
} {
	var calls []struct {
		Ctx context.Context
		ID  uuid.UUID
	}
	mock.lockGetByID.RLock()
	calls = mock.calls.GetByID
	mock.lockGetByID.RUnlock()
	return calls
}

// Store calls StoreFunc.
func (mock *TaskRepositoryMock) Store(ctx context.Context, t *domain.Task) error {
	if mock.StoreFunc == nil {
		panic("TaskRepositoryMock.StoreFunc: method is nil but TaskRepository.Store was just called")
	}
	callInfo := struct {
		Ctx context.Context
		T   *domain.Task
	}{
		Ctx: ctx,
		T:   t,
	}
	mock.lockStore.Lock()
	mock.calls.Store = append(mock.calls.Store, callInfo)
	mock.lockStore.Unlock()
	return mock.StoreFunc(ctx, t)
}

// StoreCalls gets all the calls that were made to Store.
// Check the length with:
//     len(mockedTaskRepository.StoreCalls())
func (mock *TaskRepositoryMock) StoreCalls() []struct {
	Ctx context.Context
	T   *domain.Task
} {
	var calls []struct {
		Ctx context.Context
		T   *domain.Task
	}
	mock.lockStore.RLock()
	calls = mock.calls.Store
	mock.lockStore.RUnlock()
	return calls
}

// Update calls UpdateFunc.
func (mock *TaskRepositoryMock) Update(ctx context.Context, tk *domain.Task) error {
	if mock.UpdateFunc == nil {
		panic("TaskRepositoryMock.UpdateFunc: method is nil but TaskRepository.Update was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Tk  *domain.Task
	}{
		Ctx: ctx,
		Tk:  tk,
	}
	mock.lockUpdate.Lock()
	mock.calls.Update = append(mock.calls.Update, callInfo)
	mock.lockUpdate.Unlock()
	return mock.UpdateFunc(ctx, tk)
}

// UpdateCalls gets all the calls that were made to Update.
// Check the length with:
//     len(mockedTaskRepository.UpdateCalls())
func (mock *TaskRepositoryMock) UpdateCalls() []struct {
	Ctx context.Context
	Tk  *domain.Task
} {
	var calls []struct {
		Ctx context.Context
		Tk  *domain.Task
	}
	mock.lockUpdate.RLock()
	calls = mock.calls.Update
	mock.lockUpdate.RUnlock()
	return calls
}
